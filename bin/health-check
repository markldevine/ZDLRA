#!/usr/bin/env raku

#   dbmcli -n -m -e list alerthistory

use Async::Command::Multi;
use Data::Dump::Tree;
use Our::Cache;
use JSON::Fast;

class PHYSICALDISK_RECORD {
    has Str             $.name;
    has Str             $.serial;
    has Str             $.status;
}

class ALERTHISTORY_RECORD {
    has Str             $.name;
    has DateTime        $.datetime;
    has Str             $.severity;
    has Str             $.message;
}

my @ZDLRA-dbms;
my %inventory;
my %ah-dt-cache;
my %status;
my %command;
my $id-prefix           = 'DateTime-Last-alerthistory-Record';

my @redis-servers = slurp("$*HOME/.redis-servers").chomp.split("\n");

my @redis-clis;
for @redis-servers -> $redis-server {
    my @cmd-string  = sprintf("ssh -L 127.0.0.1:6379:%s:6379 %s /usr/bin/redis-cli", $redis-server, $redis-server).split: /\s+/;
    @redis-clis.push: @cmd-string;
}

my @z-keys;
my @rcmd;
my @redis-cli;
for @redis-clis -> @r-cli {
    @rcmd           = flat @r-cli,
                      '--raw',
                      'KEYS',
                      'eb:zdlra:dbm:*';
    my $proc        = run   @rcmd, :out, :err;
    my $out         = $proc.out.slurp(:close);
    my $err         = $proc.err.slurp(:close);
    if $err {
        warn 'FAILED: ' ~ @rcmd ~ "\t[" ~ $err ~ ']';
        next;
    }
    if $out.chars {
        if @z-keys = $out.chomp.split("\n") {
            @redis-cli = @r-cli;
            last;
        }
    }
}
die "No ZDLRA dbm keys!" unless @z-keys;

for @z-keys -> $z-key {
    my @rcmd        = flat @redis-cli,
                        '--raw',
                        'LINDEX',
                        $z-key,
                        '0';
    my $proc        = run   @rcmd, :out, :err;
    my $out         = $proc.out.slurp(:close);
    my $err         = $proc.err.slurp(:close);
    die $err    if $err;
    die 'REDIS returned no VALUE for KEY ' ~ $z-key unless $out;
    @ZDLRA-dbms.push: $out.chomp;
}

class ALERTHISTORY-RECORD {
    has Str         $.name      is required;
    has DateTime    $.datetime  is required;
    has Str         $.severity  is required;
    has Str         @.message;
}

my grammar ALERTHISTORY-GRAMMAR {
    token TOP                   { <log-record>+                                                             }
    token log-record            { <log-record-start> || <log-record-continue>                               }
    token log-record-start      { ^^ <log-record-herald> \s+ <log-text>                                     }
    token log-record-herald     { \s* <name> \s+ <datetime> \s+ <severity>                                  }
    token log-record-continue   { ^^ <!before <log-record-herald>> <log-text>                               }
    token name                  { \d+ '_' \d+                                                               }
    token datetime              { \d\d\d\d '-' \d\d '-' \d\d 'T' \d\d ':' \d\d ':' \d\d '-' \d\d ':' \d\d   }
    token severity              { \w+                                                                       }
    token log-text              { .+? \n                                                                    }
}

class ALERTHISTORY-ACTIONS {
    has Str $.dbm           is required;
    has Str $.cell          is required;

    method log-record-herald ($/) {
        my $datetime        = DateTime.new(~$/<datetime>);
        %inventory{$dbm}<CELLS>{$cell}<ALERTHISTORY>.push: ALERTHISTORY-RECORD.new(
            :name(~$/<name>),
            :$datetime,
            :severity(~$/<severity>),
        );
        %ah-dt-cache{$dbm}{$cell} = $datetime if $datetime > %ah-dt-cache{$dbm}{$cell};
    }

    method log-text ($/) {
        %inventory{$dbm}<CELLS>{$cell}<ALERTHISTORY>[* - 1].message.push: ~$/.chomp;
    }
}

sub MAIN (
    Int   :$log-days        = 0,               #= log days to display (bypass "only unseen logs" mechanism)
) {
    die                     unless @ZDLRA-dbms.elems;
    %command                = ();
    for @ZDLRA-dbms -> $dbm {
        %command{$dbm}      = 'ssh', $dbm, 'sudo', 'dcli', '-l', 'root', '-g', '/root/cell_group', '"cellcli -e list physicaldisk"';
    }

    my %physicaldisk        = Async::Command::Multi.new(:%command).sow.reap;

    for %physicaldisk.keys.sort -> $dbm {
        for %physicaldisk{$dbm}.stdout-results.lines -> $record {
            my @fields      = $record.trim.split(/\s+/);
            my $cell        = @fields[0].ends-with(':') ?? @fields[0].chop(1) !! @fields[0];
            %inventory{$dbm}<CELSS>{$cell} = '';
            %status{$dbm}<PHYSICALDISK>{$cell}.push: PHYSICALDISK_RECORD.new:
                :name(@fields[1]),
                :serial(@fields[2]),
                :status(@fields[3..*].join(' '));
        }
    }

    my $identifier          = 'alerthistory_datetimes';
    my $ah-dt-cache         = Our::Cache.new(:$identifier);

    if ! $log-days && $ah-dt-cache.cache-hit {
        %ah-dt-cache        = from-json($ah-dt-cache.fetch) or note $?LINE;
        for %ah-dt-cache.keys.sort -> $dbm {
            for %ah-dt-cache{$dbm}.keys.sort -> $cell {
                %ah-dt-cache{$dbm}{$cell} = DateTime.new: %ah-dt-cache{$dbm}{$cell};
            }
        }
    }
    else {
        my $first-log       = now - (365 * 24 * 60 * 60);
        $first-log          = now - ($log-days * 24 * 60 * 60) if $log-days;
        my $first-dt        = DateTime.new(:timezone($*TZ), $first-log).truncated-to('second');
        for %inventory.keys.sort -> $dbm {
            for %inventory{$dbm}<CELLS>.keys.sort -> $cell {
                %ah-dt-cache{$dbm}{$cell} = $first-dt.clone;
            }
        }
        $ah-dt-cache.store(:data(to-json(%ah-dt-cache)));
    }

    %command                = ();
    for %inventory.keys -> $dbm {
        for %inventory{$dbm}<CELLS>.keys.sort -> $cell {
            %command{$cell} = (
                                'ssh',
                                $dbm,
                                'sudo',
                                'ssh',
                                $cell,
                                Q/"cellcli -e list alerthistory WHERE begintime \\> \\'/ ~ %ah-dt-cache{$dbm}{$cell}.Str ~ Q/\\'"/,
                            );
        }
    }

    my %alerthistory        = Async::Command::Multi.new(:%command).sow.reap;

    for %inventory.keys -> $dbm {
        for %inventory{$dbm}<CELLS>.keys.sort -> $cell {
            ALERTHISTORY-GRAMMAR.parse(%alerthistory{$cell}.stdout-results, :actions(ALERTHISTORY-ACTIONS.new(:$dbm, :$cell)));
        }
    }
    $ah-dt-cache.store(:data(to-json(%ah-dt-cache)));

    for %inventory.keys -> $dbm {
        put $dbm;
        for %inventory{$dbm}<CELLS>.keys.sort -> $cell {
            put "\t" ~ $cell;
            for %status{$dbm}<PHYSICALDISK>{$cell}.list -> $pd {
                printf "\t\t%s\t%s [%s]\n", $pd.status, $pd.name, $pd.serial if $pd.status ne 'normal';
            }
            if (%status{$dbm}<ALERTHISTORY>:exists) && (%status{$dbm}<ALERTHISTORY>{$cell}:exists) {
                for %status{$dbm}<ALERTHISTORY>{$cell}.list -> $logrcd {
                    printf "\t\t%s %s %s\n", $logrcd.datetime, $logrcd.severity, $logrcd.message;
                }
            }
        }
    }
}

=finish
