#!/usr/bin/env raku

use Async::Command::Multi;
use Data::Dump::Tree;
use Our::Cache;
use JSON::Fast;

class PHYSICALDISK_RECORD {
    has Str             $.name;
    has Str             $.serial;
    has Str             $.status;
}

class ALERTHISTORY_RECORD {
    has Str             $.name;
    has DateTime        $.datetime;
    has Str             $.precedence;
    has Str             $.message;
}

my @ZDLRA-Admins        = <ctz1dbadm01 jgz1dbadm01>;
my %inventory;
my %status;
my %command;
my $id-prefix           = 'DateTime-Last-alerthistory-Record';

%command                = ();
for @ZDLRA-Admins -> $adm {
    %command{$adm}      = 'ssh', $adm, 'sudo', 'dcli', '-l', 'root', '-g', '/root/cell_group', '"cellcli -e list physicaldisk"';
}
my %physicaldisk        = Async::Command::Multi.new(:%command).sow.reap;                                                            # ddt %physicaldisk; exit;
for %physicaldisk.keys.sort -> $adm {
    for %physicaldisk{$adm}.stdout-results.lines -> $record {
        my @fields      = $record.trim.split(/\s+/);
        my $node        = @fields[0].ends-with(':') ?? @fields[0].chop(1) !! @fields[0];
        %inventory{$adm}{$node} = '';
        %status{$adm}<PHYSICALDISK>{$node}.push: PHYSICALDISK_RECORD.new:
            :name(@fields[1]),
            :serial(@fields[2]),
            :status(@fields[3..*].join(' '));
    }
}

my $identifier          = 'alerthistory_datetimes';
my %ah-dt-cache;
my $ah-dt-cache         = Our::Cache.new(:$identifier);
if $ah-dt-cache.cache-hit {
    %ah-dt-cache        = from-json($ah-dt-cache.fetch) or note $?LINE;
    for %ah-dt-cache.keys.sort -> $adm {
        for %ah-dt-cache{$adm}.keys.sort -> $node {
            %ah-dt-cache{$adm}{$node} = DateTime.new: %ah-dt-cache{$adm}{$node};
        }
    }
}
else {
    my $one-year-ago    = now - (365 * 24 * 60 * 60);
    my $dt1ya           = DateTime.new(:timezone($*TZ), $one-year-ago).truncated-to('second');
    for %inventory.keys.sort -> $adm {
        for %inventory{$adm}.keys.sort -> $node {
            %ah-dt-cache{$adm}{$node} = $dt1ya.clone;
        }
    }
    $ah-dt-cache.store(:data(to-json(%ah-dt-cache))) or note $?LINE;
}

ddt %ah-dt-cache;

=finish





my $tz-hours        = $dt.local.offset-in-hours;
my $tz-minutes      = $dt.local.offset-in-minutes;
$tz-minutes         = $tz-minutes.abs - ($tz-hours.abs * 60);
die sprintf("%s%02d:%02d", $tz-hours < 0 ?? '-' !! '+', $tz-hours, $tz-minutes);
#my $timezone-string = 

=finish

for %inventory.keys -> $adm {
    for %inventory{$adm}.keys.sort -> $cell {

#   '2025-08-20T00:00:01-04:00'

        %command{$adm}  = (
                            'ssh',
                            $adm',
                            'sudo',
                            'ssh',
                            $cell,
                            Q/"cellcli -e list alerthistory WHERE begintime \\> \\'/ ~
                            sprintf("%d-%02d-%02dT%02d:%02d:%02d%d",
                                $dt.year,
                                $dt.month,
                                $dt.day,
                                $dt.hour,
                                $dt.minute,
                                $dt.second,
                                $timezone-string,
                            ) ~
                            Q/\\'"/,
                          );

}

#%command<ctz1celadm01>  =   (
                                'ssh',
                                'ctz1dbadm01',
                                'sudo',
                                'ssh',
                                'ctz1celadm01',
                                Q/"cellcli -e list alerthistory WHERE begintime \\> \\'/ ~ '2025-08-20T00:00:01-04:00' ~ Q/\\'"/,
                            );

for @ZDLRA-Admins -> $adm {
    %command{$adm}  = 'ssh', $adm, 'sudo', 'dcli', '-l', 'root', '-g', '/root/cell_group', '"cellcli -e list alerthistory"';
}
my %lastdt;
my %alerthistory    = Async::Command::Multi.new(:%command).sow.reap;                                                            # ddt %alerthistory; exit;

for %alerthistory.keys.sort -> $adm {
    for %alerthistory{$adm}.stdout-results.lines -> $record {
        my @fields  = $record.trim.split(/\s+/);
        my $datetime    = DateTime.new(@fields[2]);
        my $node        = @fields[0].ends-with(':') ?? @fields[0].chop(1) !! @fields[0];

die '|' ~ $node ~ '|';

        %lastdt{$adm}   = $datetime if %lastdt{$adm}:exists && $datetime > %lastdt{$adm};
        %status{$adm}<ALERTHISTORY>.push: ALERTHISTORY_RECORD.new:
            :name(@fields[1]),
            :$datetime,
            :precedence(@fields[3]),
            :message(@fields[4..*].join(' '));
    }
}

for @ZDLRA-Admins -> $adm {
    my $cache       = Our::Cache.new(:identifier($id-prefix ~ '_' ~ $adm));
    $cache.store(:data(%lastdt{$adm}.Str)) or note;
}

ddt %status;

=finish
